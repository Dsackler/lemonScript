/**
 * @module furi
 */
import assert from "assert";
import isWindows from "is-windows";
import url from "url";
class InvalidFileUri extends TypeError {
    constructor(input) {
        super();
        this.input = input;
        this.message = `Invalid file URI: ${input}`;
        this.name = "TypeError [ERR_INVALID_FILE_URI]";
        this.code = "ERR_INVALID_FILE_URI";
    }
}
/**
 * A class representing a normalized absolute `file://` URI.
 *
 * This is a subclass of `url.URL` with the following extra checks:
 * - The protocol is `file:`.
 * - The pathname does not contain consecutive slashes (`a//b`) ("normalization").
 * - The pathname does not contain the `.` or `..` segments (enforced by `url.URL` already).
 * - The host `localhost` is represented as the empty string (enforced by `url.URL` already).
 *
 * This class extends `url.URL`. This means that you can pass it to any
 * function expecting a `url.URL`. It also means that the URI is always
 * absolute.
 *
 * Notes:
 * - A single trailing slash is allowed.
 * - The hostname is allowed to be any string. A non-empty string is used by Windows to represents
 *   files on a network drive. An empty string means `localhost`.
 * - The `username`, `password` and `port` properties are always `""` (enforced by `url.URL`
 *   already). This implies that `host` only contains `hostname`.
 * - The `search` and `hash` properties can have any value.
 */
export class Furi extends url.URL {
    constructor(input) {
        const strInput = `${input}`;
        super(strInput);
        if (this.protocol !== "file:") {
            throw new InvalidFileUri(strInput);
        }
        if (this.pathname.indexOf("//") >= 0) {
            this.pathname = this.pathname.replace(/\/+/g, "/");
        }
    }
    get protocol() {
        return super.protocol;
    }
    set protocol(value) {
        if (value !== "file:") {
            return;
        }
        super.protocol = value;
    }
    get pathname() {
        return super.pathname;
    }
    set pathname(value) {
        if (value.indexOf("//") >= 0) {
            value = value.replace(/\/+/g, "/");
        }
        super.pathname = value;
    }
    hasTrailingSlash() {
        return this.pathname !== "/" && this.pathname.endsWith("/");
    }
    setTrailingSlash(hasTrailingSlash) {
        if (this.pathname === "/") {
            return;
        }
        if (this.pathname.endsWith("/")) {
            if (!hasTrailingSlash) {
                this.pathname = this.pathname.substring(0, this.pathname.length - 1);
            }
        }
        else if (hasTrailingSlash) {
            this.pathname = `${this.pathname}/`;
        }
    }
    toSysPath(windowsLongPath = false) {
        return toSysPath(this, windowsLongPath);
    }
    toPosixPath() {
        return toPosixPath(this);
    }
    toWindowsShortPath() {
        return toWindowsShortPath(this);
    }
    toWindowsLongPath() {
        return toWindowsLongPath(this);
    }
}
/**
 * Normalizes the input to a `Furi` instance.
 *
 * @param input URL string or instance to normalize.
 * @returns `Furi` instance. It is always a new instance.
 */
export function asFuri(input) {
    if (input instanceof url.URL) {
        return new Furi(input.toString());
    }
    else {
        return new Furi(input);
    }
}
/**
 * Normalizes the input to a writable `URL` instance.
 *
 * @param input URL string or instance to normalize.
 */
export function asWritableUrl(input) {
    return new url.URL(typeof input === "string" ? input : input.toString());
}
/**
 * Appends the provided components to the pathname of `base`.
 *
 * It does not mutate the inputs.
 * If component list is non-empty, the `hash` and `search` are set to the
 * empty string.
 *
 * @param base Base URL.
 * @param paths Paths to append. A path is either a string representing a relative or absolute file URI, or an array
 *              of components. When passing an array of components, each component will be URI-encoded before being
 *              appended.
 * @returns Joined URL.
 */
export function join(base, ...paths) {
    const result = asFuri(base);
    if (paths.length === 0) {
        return result;
    }
    let hasTrailingSlash = result.hasTrailingSlash();
    const segments = result.pathname.split("/");
    for (const p of paths) {
        let pathStr;
        if (typeof p === "string") {
            if (p === "") {
                continue;
            }
            pathStr = p;
        }
        else {
            if (p.length === 0) {
                continue;
            }
            pathStr = `./${p.map(encodeURIComponent).join("/")}`;
        }
        for (const segment of pathStr.split("/")) {
            segments.push(segment);
            hasTrailingSlash = segment === "";
        }
    }
    result.pathname = segments.join("/");
    result.setTrailingSlash(hasTrailingSlash);
    result.hash = "";
    result.search = "";
    return result;
}
/**
 * Computes the relative or absolute `file://` URI from `from` to `to`.
 *
 * The result is an absolute URI only if the arguments have different hosts
 * (for example when computing a URI between different Windows networked drives).
 *
 * If both URIs are equivalent, returns `""`.
 *
 * Otherwise, returns a relative URI starting with `"./"` or `"../".
 *
 * @param from Source URI.
 * @param to Destination URI.
 * @returns Relative (or absolute) URI between the two arguments.
 */
export function relative(from, to) {
    if (from === to) {
        return "";
    }
    const fromUri = asFuri(from);
    const toUri = asFuri(to);
    if (fromUri.host !== toUri.host) {
        return toUri.toString();
    }
    fromUri.setTrailingSlash(false);
    const fromSegments = fromUri.pathname === "/" ? [""] : fromUri.pathname.split("/");
    const toSegments = toUri.pathname === "/" ? [""] : toUri.pathname.split("/");
    let commonSegments = 0;
    for (let i = 0; i < Math.min(fromSegments.length, toSegments.length); i++) {
        const fromSegment = fromSegments[i];
        const toSegment = toSegments[i];
        if (fromSegment === toSegment) {
            commonSegments++;
        }
        else {
            break;
        }
    }
    const resultSegments = [];
    if (commonSegments === fromSegments.length) {
        if (commonSegments === toSegments.length) {
            // TODO: Handle hash and search
            return "";
        }
        resultSegments.push(".");
    }
    else {
        for (let i = commonSegments; i < fromSegments.length; i++) {
            resultSegments.push("..");
        }
    }
    resultSegments.push(...toSegments.slice(commonSegments));
    return resultSegments.join("/");
}
/**
 * Returns the basename of the file URI.
 *
 * This function is similar to Node's `require("path").basename`.
 *
 * @param furi Absolute `file://` URI.
 * @param ext Extension (will be removed if present).
 * @returns URI-encoded basename.
 */
export function basename(furi, ext) {
    const readable = asFuri(furi);
    const components = readable.pathname
        .split("/")
        .filter(c => c !== "");
    const basename = components.length > 0 ? components[components.length - 1] : "";
    if (ext !== undefined && ext.length > 0 && ext.length < basename.length) {
        if (basename.endsWith(ext)) {
            return basename.substr(0, basename.length - ext.length);
        }
    }
    return basename;
}
/**
 * Returns the parent URL.
 *
 * If `input` is the root, it returns itself (saturation).
 * If `input` has a trailing separator, it is first removed.
 *
 * @param input Input URL.
 * @returns Parent URL.
 */
export function parent(input) {
    const writable = asWritableUrl(input);
    const oldPathname = writable.pathname;
    const components = oldPathname.split("/");
    if (components[components.length - 1] === "") {
        // Remove trailing separator
        components.pop();
    }
    components.pop();
    writable.pathname = components.join("/");
    return writable;
}
/**
 * Converts a File URI to a system-dependent path.
 *
 * Use `toPosixPath`, `toWindowsShortPath` or `toWindowsLongPath` if you
 * want system-independent results.
 *
 * Example:
 * ```js
 * // On a Windows system:
 * toSysPath("file:///C:/dir/foo");
 * // -> "C:\\dir\\foo";
 * toSysPath("file:///C:/dir/foo", true);
 * // -> "\\\\?\\C:\\dir\\foo";
 *
 * // On a Posix system:
 * toSysPath("file:///dir/foo");
 * // -> "/dir/foo";
 * ```
 *
 * @param furi File URI to convert.
 * @param windowsLongPath Use long paths on Windows. (default: `false`)
 * @return System-dependent path.
 */
export function toSysPath(furi, windowsLongPath = false) {
    if (isWindows()) {
        return windowsLongPath ? toWindowsLongPath(furi) : toWindowsShortPath(furi);
    }
    else {
        return toPosixPath(furi);
    }
}
/**
 * Converts a File URI to a Windows short path.
 *
 * The result is either a short device path or a short UNC server path.
 *
 * Example:
 * ```js
 * toSysPath("file:///C:/dir/foo");
 * // -> "C:\\dir\\foo";
 * toSysPath("file://server/Users/foo");
 * // -> "\\\\server\\Users\\foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Windows short path.
 */
export function toWindowsShortPath(furi) {
    const urlObj = asFuri(furi);
    if (urlObj.host === "") {
        // Local drive path
        const pathname = urlObj.pathname.substring(1);
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        return toBackwardSlashes(forward);
    }
    else {
        // Server path
        const pathname = urlObj.pathname;
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\${urlObj.host}${backward}`;
    }
}
/**
 * Converts a File URI to a Windows long path.
 *
 * The result is either a long device path or a long UNC server path.
 *
 * Example:
 * ```js
 * toWindowsPath("file:///C:/dir/foo");
 * // -> "\\\\?\\C:\\dir\\foo";
 * toWindowsPath("file://server/Users/foo");
 * // -> "\\\\?\\unc\\server\\Users\\foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Windows long path.
 */
export function toWindowsLongPath(furi) {
    const urlObj = asFuri(furi);
    if (urlObj.host === "") {
        // Local drive path
        const pathname = urlObj.pathname.substring(1);
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\?\\${backward}`;
    }
    else {
        // Server path
        const pathname = urlObj.pathname;
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\?\\unc\\${urlObj.host}${backward}`;
    }
}
/**
 * Converts a File URI to a Posix path.
 *
 * Requires the host to be either an empty string or `"localhost"`.
 *
 * Example:
 * ```js
 * toPosixPath("file:///dir/foo");
 * // -> "/dir/foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Posix path.
 */
export function toPosixPath(furi) {
    const urlObj = asFuri(furi);
    if (urlObj.host !== "" && urlObj.host !== "localhost") {
        assert.fail(`Expected \`host\` to be "" or "localhost": ${furi}`);
    }
    const pathname = urlObj.pathname;
    return pathname.split("/").map(decodeURIComponent).join("/");
}
/**
 * Converts an absolute system-dependent path to a frozen URL object.
 *
 * Use `fromPosixPath` or `fromWindowsPath` if you want system-independent
 * results.
 *
 * Example:
 * ```js
 * // On a Windows system:
 * fromSysPath("C:\\dir\\foo");
 * // -> new URL("file:///C:/dir/foo");
 *
 * // On a Posix system:
 * fromSysPath("/dir/foo");
 * // -> new URL("file:///dir/foo");
 * ```
 *
 * @param absPath Absolute system-dependent path to convert
 * @return Frozen `file://` URL object.
 */
export function fromSysPath(absPath) {
    return isWindows() ? fromWindowsPath(absPath) : fromPosixPath(absPath);
}
const WINDOWS_PREFIX_REGEX = /^[\\/]{2,}([^\\/]+)(?:$|[\\/]+)/;
const WINDOWS_UNC_REGEX = /^unc(?:$|[\\/]+)([^\\/]+)(?:$|[\\/]+)/i;
/**
 * Converts an absolute Windows path to a frozen URL object.
 *
 * Example:
 * ```js
 * fromWindowsPath("C:\\dir\\foo");
 * // -> new URL(file:///C:/dir/foo");
 * fromWindowsPath("\\\\?\\unc\\server\\Users\\foo");
 * // -> new URL("file://server/Users/foo");
 * ```
 *
 * @param absPath Absolute Windows path to convert
 * @return Frozen `file://` URL object.
 */
export function fromWindowsPath(absPath) {
    const prefixMatch = WINDOWS_PREFIX_REGEX.exec(absPath);
    if (prefixMatch === null) {
        // Short device path
        return formatFileUrl(`/${toForwardSlashes(absPath)}`);
    }
    const prefix = prefixMatch[1];
    const tail = absPath.substring(prefixMatch[0].length);
    if (prefix !== "?") {
        // Short server path
        const result = new url.URL("file:///");
        result.host = prefix;
        result.pathname = encodeURI(`/${toForwardSlashes(tail)}`);
        return result;
    }
    // Long path
    const uncMatch = WINDOWS_UNC_REGEX.exec(tail);
    if (uncMatch === null) {
        // Long device path
        return formatFileUrl(`/${toForwardSlashes(tail)}`);
    }
    else {
        // Long server path
        const host = uncMatch[1];
        const serverPath = tail.substring(uncMatch[0].length);
        const result = new url.URL("file:///");
        result.host = host;
        result.pathname = encodeURI(`/${toForwardSlashes(serverPath)}`);
        return result;
    }
}
/**
 * Converts an absolute Posix path to a frozen URL object.
 *
 * Example:
 * ```js
 * fromPosixPath("/dir/foo");
 * // -> new URL(file:///dir/foo");
 * ```
 *
 * @param absPath Absolute Posix path to convert
 * @return Frozen `file://` URL object.
 */
export function fromPosixPath(absPath) {
    return formatFileUrl(absPath);
}
/**
 * Replaces all the backward slashes by forward slashes.
 *
 * @param str Input string.
 * @internal
 */
function toForwardSlashes(str) {
    return str.replace(/\\/g, "/");
}
/**
 * Replaces all the forward slashes by backward slashes.
 *
 * @param str Input string.
 * @internal
 */
function toBackwardSlashes(str) {
    return str.replace(/\//g, "\\");
}
/**
 * Creates a frozen `file://` URL using the supplied `pathname`.
 *
 * @param pathname Pathname for the URL object.
 * @return Frozen `file://` URL object.
 * @internal
 */
function formatFileUrl(pathname) {
    const result = new url.URL("file:///");
    result.pathname = encodeURI(pathname);
    return result;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ25CLE1BQU0sQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2hFLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7QUFDSCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUFDLE9BQWU7SUFDM0MsT0FBTyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEMsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxHQUFXO0lBQ25DLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxpQkFBaUIsQ0FBQyxHQUFXO0lBQ3BDLE9BQU8sR0FBRyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDbEMsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQVMsYUFBYSxDQUFDLFFBQWdCO0lBQ3JDLE1BQU0sTUFBTSxHQUFZLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNoRCxNQUFNLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN0QyxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9kdWxlIGZ1cmlcbiAqL1xuXG5pbXBvcnQgYXNzZXJ0IGZyb20gXCJhc3NlcnRcIjtcbmltcG9ydCBpc1dpbmRvd3MgZnJvbSBcImlzLXdpbmRvd3NcIjtcbmltcG9ydCB1cmwgZnJvbSBcInVybFwiO1xuXG5jbGFzcyBJbnZhbGlkRmlsZVVyaSBleHRlbmRzIFR5cGVFcnJvciB7XG4gIHB1YmxpYyBpbnB1dDogc3RyaW5nO1xuICBwdWJsaWMgY29kZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGlucHV0OiBzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBmaWxlIFVSSTogJHtpbnB1dH1gO1xuICAgIHRoaXMubmFtZSA9IFwiVHlwZUVycm9yIFtFUlJfSU5WQUxJRF9GSUxFX1VSSV1cIjtcbiAgICB0aGlzLmNvZGUgPSBcIkVSUl9JTlZBTElEX0ZJTEVfVVJJXCI7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIG5vcm1hbGl6ZWQgYWJzb2x1dGUgYGZpbGU6Ly9gIFVSSS5cbiAqXG4gKiBUaGlzIGlzIGEgc3ViY2xhc3Mgb2YgYHVybC5VUkxgIHdpdGggdGhlIGZvbGxvd2luZyBleHRyYSBjaGVja3M6XG4gKiAtIFRoZSBwcm90b2NvbCBpcyBgZmlsZTpgLlxuICogLSBUaGUgcGF0aG5hbWUgZG9lcyBub3QgY29udGFpbiBjb25zZWN1dGl2ZSBzbGFzaGVzIChgYS8vYmApIChcIm5vcm1hbGl6YXRpb25cIikuXG4gKiAtIFRoZSBwYXRobmFtZSBkb2VzIG5vdCBjb250YWluIHRoZSBgLmAgb3IgYC4uYCBzZWdtZW50cyAoZW5mb3JjZWQgYnkgYHVybC5VUkxgIGFscmVhZHkpLlxuICogLSBUaGUgaG9zdCBgbG9jYWxob3N0YCBpcyByZXByZXNlbnRlZCBhcyB0aGUgZW1wdHkgc3RyaW5nIChlbmZvcmNlZCBieSBgdXJsLlVSTGAgYWxyZWFkeSkuXG4gKlxuICogVGhpcyBjbGFzcyBleHRlbmRzIGB1cmwuVVJMYC4gVGhpcyBtZWFucyB0aGF0IHlvdSBjYW4gcGFzcyBpdCB0byBhbnlcbiAqIGZ1bmN0aW9uIGV4cGVjdGluZyBhIGB1cmwuVVJMYC4gSXQgYWxzbyBtZWFucyB0aGF0IHRoZSBVUkkgaXMgYWx3YXlzXG4gKiBhYnNvbHV0ZS5cbiAqXG4gKiBOb3RlczpcbiAqIC0gQSBzaW5nbGUgdHJhaWxpbmcgc2xhc2ggaXMgYWxsb3dlZC5cbiAqIC0gVGhlIGhvc3RuYW1lIGlzIGFsbG93ZWQgdG8gYmUgYW55IHN0cmluZy4gQSBub24tZW1wdHkgc3RyaW5nIGlzIHVzZWQgYnkgV2luZG93cyB0byByZXByZXNlbnRzXG4gKiAgIGZpbGVzIG9uIGEgbmV0d29yayBkcml2ZS4gQW4gZW1wdHkgc3RyaW5nIG1lYW5zIGBsb2NhbGhvc3RgLlxuICogLSBUaGUgYHVzZXJuYW1lYCwgYHBhc3N3b3JkYCBhbmQgYHBvcnRgIHByb3BlcnRpZXMgYXJlIGFsd2F5cyBgXCJcImAgKGVuZm9yY2VkIGJ5IGB1cmwuVVJMYFxuICogICBhbHJlYWR5KS4gVGhpcyBpbXBsaWVzIHRoYXQgYGhvc3RgIG9ubHkgY29udGFpbnMgYGhvc3RuYW1lYC5cbiAqIC0gVGhlIGBzZWFyY2hgIGFuZCBgaGFzaGAgcHJvcGVydGllcyBjYW4gaGF2ZSBhbnkgdmFsdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBGdXJpIGV4dGVuZHMgdXJsLlVSTCB7XG4gIGNvbnN0cnVjdG9yKGlucHV0OiBVcmxMaWtlKSB7XG4gICAgY29uc3Qgc3RySW5wdXQ6IHN0cmluZyA9IGAke2lucHV0fWA7XG4gICAgc3VwZXIoc3RySW5wdXQpO1xuICAgIGlmICh0aGlzLnByb3RvY29sICE9PSBcImZpbGU6XCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRmlsZVVyaShzdHJJbnB1dCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGhuYW1lLmluZGV4T2YoXCIvL1wiKSA+PSAwKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gdGhpcy5wYXRobmFtZS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcHJvdG9jb2woKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3VwZXIucHJvdG9jb2w7XG4gIH1cblxuICBzZXQgcHJvdG9jb2wodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZSAhPT0gXCJmaWxlOlwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnByb3RvY29sID0gdmFsdWU7XG4gIH1cblxuICBnZXQgcGF0aG5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gc3VwZXIucGF0aG5hbWU7XG4gIH1cblxuICBzZXQgcGF0aG5hbWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh2YWx1ZS5pbmRleE9mKFwiLy9cIikgPj0gMCkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbiAgICB9XG4gICAgc3VwZXIucGF0aG5hbWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGhhc1RyYWlsaW5nU2xhc2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMucGF0aG5hbWUgIT09IFwiL1wiICYmIHRoaXMucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICB9XG5cbiAgc2V0VHJhaWxpbmdTbGFzaChoYXNUcmFpbGluZ1NsYXNoOiBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucGF0aG5hbWUgPT09IFwiL1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgaWYgKCFoYXNUcmFpbGluZ1NsYXNoKSB7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lLnN1YnN0cmluZygwLCB0aGlzLnBhdGhuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzVHJhaWxpbmdTbGFzaCkge1xuICAgICAgdGhpcy5wYXRobmFtZSA9IGAke3RoaXMucGF0aG5hbWV9L2A7XG4gICAgfVxuICB9XG5cbiAgdG9TeXNQYXRoKHdpbmRvd3NMb25nUGF0aDogYm9vbGVhbiA9IGZhbHNlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdG9TeXNQYXRoKHRoaXMsIHdpbmRvd3NMb25nUGF0aCk7XG4gIH1cblxuICB0b1Bvc2l4UGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1Bvc2l4UGF0aCh0aGlzKTtcbiAgfVxuXG4gIHRvV2luZG93c1Nob3J0UGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1dpbmRvd3NTaG9ydFBhdGgodGhpcyk7XG4gIH1cblxuICB0b1dpbmRvd3NMb25nUGF0aCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1dpbmRvd3NMb25nUGF0aCh0aGlzKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgYFVSTGAgaW5zdGFuY2Ugb3IgdmFsaWQgX2Fic29sdXRlXyBVUkwgc3RyaW5nLlxuICovXG5leHBvcnQgdHlwZSBVcmxMaWtlID0gdXJsLlVSTCB8IHN0cmluZztcblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBpbnB1dCB0byBhIGBGdXJpYCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgVVJMIHN0cmluZyBvciBpbnN0YW5jZSB0byBub3JtYWxpemUuXG4gKiBAcmV0dXJucyBgRnVyaWAgaW5zdGFuY2UuIEl0IGlzIGFsd2F5cyBhIG5ldyBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzRnVyaShpbnB1dDogVXJsTGlrZSk6IEZ1cmkge1xuICBpZiAoaW5wdXQgaW5zdGFuY2VvZiB1cmwuVVJMKSB7XG4gICAgcmV0dXJuIG5ldyBGdXJpKGlucHV0LnRvU3RyaW5nKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgRnVyaShpbnB1dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBpbnB1dCB0byBhIHdyaXRhYmxlIGBVUkxgIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBpbnB1dCBVUkwgc3RyaW5nIG9yIGluc3RhbmNlIHRvIG5vcm1hbGl6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzV3JpdGFibGVVcmwoaW5wdXQ6IFVybExpa2UpOiB1cmwuVVJMIHtcbiAgcmV0dXJuIG5ldyB1cmwuVVJMKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IGlucHV0IDogaW5wdXQudG9TdHJpbmcoKSk7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgcHJvdmlkZWQgY29tcG9uZW50cyB0byB0aGUgcGF0aG5hbWUgb2YgYGJhc2VgLlxuICpcbiAqIEl0IGRvZXMgbm90IG11dGF0ZSB0aGUgaW5wdXRzLlxuICogSWYgY29tcG9uZW50IGxpc3QgaXMgbm9uLWVtcHR5LCB0aGUgYGhhc2hgIGFuZCBgc2VhcmNoYCBhcmUgc2V0IHRvIHRoZVxuICogZW1wdHkgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBiYXNlIEJhc2UgVVJMLlxuICogQHBhcmFtIHBhdGhzIFBhdGhzIHRvIGFwcGVuZC4gQSBwYXRoIGlzIGVpdGhlciBhIHN0cmluZyByZXByZXNlbnRpbmcgYSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBmaWxlIFVSSSwgb3IgYW4gYXJyYXlcbiAqICAgICAgICAgICAgICBvZiBjb21wb25lbnRzLiBXaGVuIHBhc3NpbmcgYW4gYXJyYXkgb2YgY29tcG9uZW50cywgZWFjaCBjb21wb25lbnQgd2lsbCBiZSBVUkktZW5jb2RlZCBiZWZvcmUgYmVpbmdcbiAqICAgICAgICAgICAgICBhcHBlbmRlZC5cbiAqIEByZXR1cm5zIEpvaW5lZCBVUkwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luKGJhc2U6IFVybExpa2UsIC4uLnBhdGhzOiByZWFkb25seSAoc3RyaW5nIHwgcmVhZG9ubHkgc3RyaW5nW10pW10pOiBGdXJpIHtcbiAgY29uc3QgcmVzdWx0OiBGdXJpID0gYXNGdXJpKGJhc2UpO1xuICBpZiAocGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGxldCBoYXNUcmFpbGluZ1NsYXNoOiBib29sZWFuID0gcmVzdWx0Lmhhc1RyYWlsaW5nU2xhc2goKTtcbiAgY29uc3Qgc2VnbWVudHM6IHN0cmluZ1tdID0gcmVzdWx0LnBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgZm9yIChjb25zdCBwIG9mIHBhdGhzKSB7XG4gICAgbGV0IHBhdGhTdHI6IHN0cmluZztcbiAgICBpZiAodHlwZW9mIHAgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChwID09PSBcIlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcGF0aFN0ciA9IHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHBhdGhTdHIgPSBgLi8ke3AubWFwKGVuY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIil9YDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHBhdGhTdHIuc3BsaXQoXCIvXCIpKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgaGFzVHJhaWxpbmdTbGFzaCA9IHNlZ21lbnQgPT09IFwiXCI7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5wYXRobmFtZSA9IHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICByZXN1bHQuc2V0VHJhaWxpbmdTbGFzaChoYXNUcmFpbGluZ1NsYXNoKTtcbiAgcmVzdWx0Lmhhc2ggPSBcIlwiO1xuICByZXN1bHQuc2VhcmNoID0gXCJcIjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgcmVsYXRpdmUgb3IgYWJzb2x1dGUgYGZpbGU6Ly9gIFVSSSBmcm9tIGBmcm9tYCB0byBgdG9gLlxuICpcbiAqIFRoZSByZXN1bHQgaXMgYW4gYWJzb2x1dGUgVVJJIG9ubHkgaWYgdGhlIGFyZ3VtZW50cyBoYXZlIGRpZmZlcmVudCBob3N0c1xuICogKGZvciBleGFtcGxlIHdoZW4gY29tcHV0aW5nIGEgVVJJIGJldHdlZW4gZGlmZmVyZW50IFdpbmRvd3MgbmV0d29ya2VkIGRyaXZlcykuXG4gKlxuICogSWYgYm90aCBVUklzIGFyZSBlcXVpdmFsZW50LCByZXR1cm5zIGBcIlwiYC5cbiAqXG4gKiBPdGhlcndpc2UsIHJldHVybnMgYSByZWxhdGl2ZSBVUkkgc3RhcnRpbmcgd2l0aCBgXCIuL1wiYCBvciBgXCIuLi9cIi5cbiAqXG4gKiBAcGFyYW0gZnJvbSBTb3VyY2UgVVJJLlxuICogQHBhcmFtIHRvIERlc3RpbmF0aW9uIFVSSS5cbiAqIEByZXR1cm5zIFJlbGF0aXZlIChvciBhYnNvbHV0ZSkgVVJJIGJldHdlZW4gdGhlIHR3byBhcmd1bWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWxhdGl2ZShmcm9tOiBVcmxMaWtlLCB0bzogVXJsTGlrZSk6IHN0cmluZyB7XG4gIGlmIChmcm9tID09PSB0bykge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IGZyb21Vcmk6IEZ1cmkgPSBhc0Z1cmkoZnJvbSk7XG4gIGNvbnN0IHRvVXJpOiBGdXJpID0gYXNGdXJpKHRvKTtcbiAgaWYgKGZyb21VcmkuaG9zdCAhPT0gdG9VcmkuaG9zdCkge1xuICAgIHJldHVybiB0b1VyaS50b1N0cmluZygpO1xuICB9XG4gIGZyb21Vcmkuc2V0VHJhaWxpbmdTbGFzaChmYWxzZSk7XG4gIGNvbnN0IGZyb21TZWdtZW50czogc3RyaW5nW10gPSBmcm9tVXJpLnBhdGhuYW1lID09PSBcIi9cIiA/IFtcIlwiXSA6IGZyb21VcmkucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICBjb25zdCB0b1NlZ21lbnRzOiBzdHJpbmdbXSA9IHRvVXJpLnBhdGhuYW1lID09PSBcIi9cIiA/IFtcIlwiXSA6IHRvVXJpLnBhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgbGV0IGNvbW1vblNlZ21lbnRzOiBudW1iZXIgPSAwO1xuICBmb3IgKGxldCBpOiBudW1iZXIgPSAwOyBpIDwgTWF0aC5taW4oZnJvbVNlZ21lbnRzLmxlbmd0aCwgdG9TZWdtZW50cy5sZW5ndGgpOyBpKyspIHtcbiAgICBjb25zdCBmcm9tU2VnbWVudDogc3RyaW5nID0gZnJvbVNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IHRvU2VnbWVudDogc3RyaW5nID0gdG9TZWdtZW50c1tpXTtcbiAgICBpZiAoZnJvbVNlZ21lbnQgPT09IHRvU2VnbWVudCkge1xuICAgICAgY29tbW9uU2VnbWVudHMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3VsdFNlZ21lbnRzOiBzdHJpbmdbXSA9IFtdO1xuICBpZiAoY29tbW9uU2VnbWVudHMgPT09IGZyb21TZWdtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAoY29tbW9uU2VnbWVudHMgPT09IHRvU2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBUT0RPOiBIYW5kbGUgaGFzaCBhbmQgc2VhcmNoXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgcmVzdWx0U2VnbWVudHMucHVzaChcIi5cIik7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaTogbnVtYmVyID0gY29tbW9uU2VnbWVudHM7IGkgPCBmcm9tU2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFNlZ21lbnRzLnB1c2goXCIuLlwiKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0U2VnbWVudHMucHVzaCguLi50b1NlZ21lbnRzLnNsaWNlKGNvbW1vblNlZ21lbnRzKSk7XG4gIHJldHVybiByZXN1bHRTZWdtZW50cy5qb2luKFwiL1wiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBiYXNlbmFtZSBvZiB0aGUgZmlsZSBVUkkuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIE5vZGUncyBgcmVxdWlyZShcInBhdGhcIikuYmFzZW5hbWVgLlxuICpcbiAqIEBwYXJhbSBmdXJpIEFic29sdXRlIGBmaWxlOi8vYCBVUkkuXG4gKiBAcGFyYW0gZXh0IEV4dGVuc2lvbiAod2lsbCBiZSByZW1vdmVkIGlmIHByZXNlbnQpLlxuICogQHJldHVybnMgVVJJLWVuY29kZWQgYmFzZW5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlbmFtZShmdXJpOiBVcmxMaWtlLCBleHQ/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCByZWFkYWJsZTogdXJsLlVSTCA9IGFzRnVyaShmdXJpKTtcbiAgY29uc3QgY29tcG9uZW50czogcmVhZG9ubHkgc3RyaW5nW10gPSByZWFkYWJsZS5wYXRobmFtZVxuICAgIC5zcGxpdChcIi9cIilcbiAgICAuZmlsdGVyKGMgPT4gYyAhPT0gXCJcIik7XG4gIGNvbnN0IGJhc2VuYW1lOiBzdHJpbmcgPSBjb21wb25lbnRzLmxlbmd0aCA+IDAgPyBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gOiBcIlwiO1xuICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8IGJhc2VuYW1lLmxlbmd0aCkge1xuICAgIGlmIChiYXNlbmFtZS5lbmRzV2l0aChleHQpKSB7XG4gICAgICByZXR1cm4gYmFzZW5hbWUuc3Vic3RyKDAsIGJhc2VuYW1lLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZW5hbWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50IFVSTC5cbiAqXG4gKiBJZiBgaW5wdXRgIGlzIHRoZSByb290LCBpdCByZXR1cm5zIGl0c2VsZiAoc2F0dXJhdGlvbikuXG4gKiBJZiBgaW5wdXRgIGhhcyBhIHRyYWlsaW5nIHNlcGFyYXRvciwgaXQgaXMgZmlyc3QgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgSW5wdXQgVVJMLlxuICogQHJldHVybnMgUGFyZW50IFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcmVudChpbnB1dDogVXJsTGlrZSk6IHVybC5VUkwge1xuICBjb25zdCB3cml0YWJsZTogdXJsLlVSTCA9IGFzV3JpdGFibGVVcmwoaW5wdXQpO1xuICBjb25zdCBvbGRQYXRobmFtZTogc3RyaW5nID0gd3JpdGFibGUucGF0aG5hbWU7XG4gIGNvbnN0IGNvbXBvbmVudHM6IHN0cmluZ1tdID0gb2xkUGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICBpZiAoY29tcG9uZW50c1tjb21wb25lbnRzLmxlbmd0aCAtIDFdID09PSBcIlwiKSB7XG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHNlcGFyYXRvclxuICAgIGNvbXBvbmVudHMucG9wKCk7XG4gIH1cbiAgY29tcG9uZW50cy5wb3AoKTtcbiAgd3JpdGFibGUucGF0aG5hbWUgPSBjb21wb25lbnRzLmpvaW4oXCIvXCIpO1xuICByZXR1cm4gd3JpdGFibGU7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBGaWxlIFVSSSB0byBhIHN5c3RlbS1kZXBlbmRlbnQgcGF0aC5cbiAqXG4gKiBVc2UgYHRvUG9zaXhQYXRoYCwgYHRvV2luZG93c1Nob3J0UGF0aGAgb3IgYHRvV2luZG93c0xvbmdQYXRoYCBpZiB5b3VcbiAqIHdhbnQgc3lzdGVtLWluZGVwZW5kZW50IHJlc3VsdHMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBPbiBhIFdpbmRvd3Mgc3lzdGVtOlxuICogdG9TeXNQYXRoKFwiZmlsZTovLy9DOi9kaXIvZm9vXCIpO1xuICogLy8gLT4gXCJDOlxcXFxkaXJcXFxcZm9vXCI7XG4gKiB0b1N5c1BhdGgoXCJmaWxlOi8vL0M6L2Rpci9mb29cIiwgdHJ1ZSk7XG4gKiAvLyAtPiBcIlxcXFxcXFxcP1xcXFxDOlxcXFxkaXJcXFxcZm9vXCI7XG4gKlxuICogLy8gT24gYSBQb3NpeCBzeXN0ZW06XG4gKiB0b1N5c1BhdGgoXCJmaWxlOi8vL2Rpci9mb29cIik7XG4gKiAvLyAtPiBcIi9kaXIvZm9vXCI7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZnVyaSBGaWxlIFVSSSB0byBjb252ZXJ0LlxuICogQHBhcmFtIHdpbmRvd3NMb25nUGF0aCBVc2UgbG9uZyBwYXRocyBvbiBXaW5kb3dzLiAoZGVmYXVsdDogYGZhbHNlYClcbiAqIEByZXR1cm4gU3lzdGVtLWRlcGVuZGVudCBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TeXNQYXRoKGZ1cmk6IFVybExpa2UsIHdpbmRvd3NMb25nUGF0aDogYm9vbGVhbiA9IGZhbHNlKTogc3RyaW5nIHtcbiAgaWYgKGlzV2luZG93cygpKSB7XG4gICAgcmV0dXJuIHdpbmRvd3NMb25nUGF0aCA/IHRvV2luZG93c0xvbmdQYXRoKGZ1cmkpIDogdG9XaW5kb3dzU2hvcnRQYXRoKGZ1cmkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b1Bvc2l4UGF0aChmdXJpKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgRmlsZSBVUkkgdG8gYSBXaW5kb3dzIHNob3J0IHBhdGguXG4gKlxuICogVGhlIHJlc3VsdCBpcyBlaXRoZXIgYSBzaG9ydCBkZXZpY2UgcGF0aCBvciBhIHNob3J0IFVOQyBzZXJ2ZXIgcGF0aC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIHRvU3lzUGF0aChcImZpbGU6Ly8vQzovZGlyL2Zvb1wiKTtcbiAqIC8vIC0+IFwiQzpcXFxcZGlyXFxcXGZvb1wiO1xuICogdG9TeXNQYXRoKFwiZmlsZTovL3NlcnZlci9Vc2Vycy9mb29cIik7XG4gKiAvLyAtPiBcIlxcXFxcXFxcc2VydmVyXFxcXFVzZXJzXFxcXGZvb1wiO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGZ1cmkgRmlsZSBVUkkgdG8gY29udmVydC5cbiAqIEByZXR1cm4gV2luZG93cyBzaG9ydCBwYXRoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9XaW5kb3dzU2hvcnRQYXRoKGZ1cmk6IFVybExpa2UpOiBzdHJpbmcge1xuICBjb25zdCB1cmxPYmo6IHVybC5VUkwgPSBhc0Z1cmkoZnVyaSk7XG4gIGlmICh1cmxPYmouaG9zdCA9PT0gXCJcIikge1xuICAgIC8vIExvY2FsIGRyaXZlIHBhdGhcbiAgICBjb25zdCBwYXRobmFtZTogc3RyaW5nID0gdXJsT2JqLnBhdGhuYW1lLnN1YnN0cmluZygxKTtcbiAgICBjb25zdCBmb3J3YXJkOiBzdHJpbmcgPSBwYXRobmFtZS5zcGxpdChcIi9cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7XG4gICAgcmV0dXJuIHRvQmFja3dhcmRTbGFzaGVzKGZvcndhcmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFNlcnZlciBwYXRoXG4gICAgY29uc3QgcGF0aG5hbWU6IHN0cmluZyA9IHVybE9iai5wYXRobmFtZTtcbiAgICBjb25zdCBmb3J3YXJkOiBzdHJpbmcgPSBwYXRobmFtZS5zcGxpdChcIi9cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7XG4gICAgY29uc3QgYmFja3dhcmQ6IHN0cmluZyA9IHRvQmFja3dhcmRTbGFzaGVzKGZvcndhcmQpO1xuICAgIHJldHVybiBgXFxcXFxcXFwke3VybE9iai5ob3N0fSR7YmFja3dhcmR9YDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgRmlsZSBVUkkgdG8gYSBXaW5kb3dzIGxvbmcgcGF0aC5cbiAqXG4gKiBUaGUgcmVzdWx0IGlzIGVpdGhlciBhIGxvbmcgZGV2aWNlIHBhdGggb3IgYSBsb25nIFVOQyBzZXJ2ZXIgcGF0aC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIHRvV2luZG93c1BhdGgoXCJmaWxlOi8vL0M6L2Rpci9mb29cIik7XG4gKiAvLyAtPiBcIlxcXFxcXFxcP1xcXFxDOlxcXFxkaXJcXFxcZm9vXCI7XG4gKiB0b1dpbmRvd3NQYXRoKFwiZmlsZTovL3NlcnZlci9Vc2Vycy9mb29cIik7XG4gKiAvLyAtPiBcIlxcXFxcXFxcP1xcXFx1bmNcXFxcc2VydmVyXFxcXFVzZXJzXFxcXGZvb1wiO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGZ1cmkgRmlsZSBVUkkgdG8gY29udmVydC5cbiAqIEByZXR1cm4gV2luZG93cyBsb25nIHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1dpbmRvd3NMb25nUGF0aChmdXJpOiBVcmxMaWtlKTogc3RyaW5nIHtcbiAgY29uc3QgdXJsT2JqOiBGdXJpID0gYXNGdXJpKGZ1cmkpO1xuICBpZiAodXJsT2JqLmhvc3QgPT09IFwiXCIpIHtcbiAgICAvLyBMb2NhbCBkcml2ZSBwYXRoXG4gICAgY29uc3QgcGF0aG5hbWU6IHN0cmluZyA9IHVybE9iai5wYXRobmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgY29uc3QgZm9yd2FyZDogc3RyaW5nID0gcGF0aG5hbWUuc3BsaXQoXCIvXCIpLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO1xuICAgIGNvbnN0IGJhY2t3YXJkOiBzdHJpbmcgPSB0b0JhY2t3YXJkU2xhc2hlcyhmb3J3YXJkKTtcbiAgICByZXR1cm4gYFxcXFxcXFxcP1xcXFwke2JhY2t3YXJkfWA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2VydmVyIHBhdGhcbiAgICBjb25zdCBwYXRobmFtZTogc3RyaW5nID0gdXJsT2JqLnBhdGhuYW1lO1xuICAgIGNvbnN0IGZvcndhcmQ6IHN0cmluZyA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiL1wiKTtcbiAgICBjb25zdCBiYWNrd2FyZDogc3RyaW5nID0gdG9CYWNrd2FyZFNsYXNoZXMoZm9yd2FyZCk7XG4gICAgcmV0dXJuIGBcXFxcXFxcXD9cXFxcdW5jXFxcXCR7dXJsT2JqLmhvc3R9JHtiYWNrd2FyZH1gO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBGaWxlIFVSSSB0byBhIFBvc2l4IHBhdGguXG4gKlxuICogUmVxdWlyZXMgdGhlIGhvc3QgdG8gYmUgZWl0aGVyIGFuIGVtcHR5IHN0cmluZyBvciBgXCJsb2NhbGhvc3RcImAuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB0b1Bvc2l4UGF0aChcImZpbGU6Ly8vZGlyL2Zvb1wiKTtcbiAqIC8vIC0+IFwiL2Rpci9mb29cIjtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBmdXJpIEZpbGUgVVJJIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJuIFBvc2l4IHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1Bvc2l4UGF0aChmdXJpOiBVcmxMaWtlKTogc3RyaW5nIHtcbiAgY29uc3QgdXJsT2JqOiBGdXJpID0gYXNGdXJpKGZ1cmkpO1xuICBpZiAodXJsT2JqLmhvc3QgIT09IFwiXCIgJiYgdXJsT2JqLmhvc3QgIT09IFwibG9jYWxob3N0XCIpIHtcbiAgICBhc3NlcnQuZmFpbChgRXhwZWN0ZWQgXFxgaG9zdFxcYCB0byBiZSBcIlwiIG9yIFwibG9jYWxob3N0XCI6ICR7ZnVyaX1gKTtcbiAgfVxuICBjb25zdCBwYXRobmFtZTogc3RyaW5nID0gdXJsT2JqLnBhdGhuYW1lO1xuICByZXR1cm4gcGF0aG5hbWUuc3BsaXQoXCIvXCIpLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFic29sdXRlIHN5c3RlbS1kZXBlbmRlbnQgcGF0aCB0byBhIGZyb3plbiBVUkwgb2JqZWN0LlxuICpcbiAqIFVzZSBgZnJvbVBvc2l4UGF0aGAgb3IgYGZyb21XaW5kb3dzUGF0aGAgaWYgeW91IHdhbnQgc3lzdGVtLWluZGVwZW5kZW50XG4gKiByZXN1bHRzLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogLy8gT24gYSBXaW5kb3dzIHN5c3RlbTpcbiAqIGZyb21TeXNQYXRoKFwiQzpcXFxcZGlyXFxcXGZvb1wiKTtcbiAqIC8vIC0+IG5ldyBVUkwoXCJmaWxlOi8vL0M6L2Rpci9mb29cIik7XG4gKlxuICogLy8gT24gYSBQb3NpeCBzeXN0ZW06XG4gKiBmcm9tU3lzUGF0aChcIi9kaXIvZm9vXCIpO1xuICogLy8gLT4gbmV3IFVSTChcImZpbGU6Ly8vZGlyL2Zvb1wiKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYnNQYXRoIEFic29sdXRlIHN5c3RlbS1kZXBlbmRlbnQgcGF0aCB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIEZyb3plbiBgZmlsZTovL2AgVVJMIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TeXNQYXRoKGFic1BhdGg6IHN0cmluZyk6IHVybC5VUkwge1xuICByZXR1cm4gaXNXaW5kb3dzKCkgPyBmcm9tV2luZG93c1BhdGgoYWJzUGF0aCkgOiBmcm9tUG9zaXhQYXRoKGFic1BhdGgpO1xufVxuXG5jb25zdCBXSU5ET1dTX1BSRUZJWF9SRUdFWDogUmVnRXhwID0gL15bXFxcXC9dezIsfShbXlxcXFwvXSspKD86JHxbXFxcXC9dKykvO1xuY29uc3QgV0lORE9XU19VTkNfUkVHRVg6IFJlZ0V4cCA9IC9edW5jKD86JHxbXFxcXC9dKykoW15cXFxcL10rKSg/OiR8W1xcXFwvXSspL2k7XG5cbi8qKlxuICogQ29udmVydHMgYW4gYWJzb2x1dGUgV2luZG93cyBwYXRoIHRvIGEgZnJvemVuIFVSTCBvYmplY3QuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBmcm9tV2luZG93c1BhdGgoXCJDOlxcXFxkaXJcXFxcZm9vXCIpO1xuICogLy8gLT4gbmV3IFVSTChmaWxlOi8vL0M6L2Rpci9mb29cIik7XG4gKiBmcm9tV2luZG93c1BhdGgoXCJcXFxcXFxcXD9cXFxcdW5jXFxcXHNlcnZlclxcXFxVc2Vyc1xcXFxmb29cIik7XG4gKiAvLyAtPiBuZXcgVVJMKFwiZmlsZTovL3NlcnZlci9Vc2Vycy9mb29cIik7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJzUGF0aCBBYnNvbHV0ZSBXaW5kb3dzIHBhdGggdG8gY29udmVydFxuICogQHJldHVybiBGcm96ZW4gYGZpbGU6Ly9gIFVSTCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tV2luZG93c1BhdGgoYWJzUGF0aDogc3RyaW5nKTogdXJsLlVSTCB7XG4gIGNvbnN0IHByZWZpeE1hdGNoOiBSZWdFeHBFeGVjQXJyYXkgfCBudWxsID0gV0lORE9XU19QUkVGSVhfUkVHRVguZXhlYyhhYnNQYXRoKTtcbiAgaWYgKHByZWZpeE1hdGNoID09PSBudWxsKSB7XG4gICAgLy8gU2hvcnQgZGV2aWNlIHBhdGhcbiAgICByZXR1cm4gZm9ybWF0RmlsZVVybChgLyR7dG9Gb3J3YXJkU2xhc2hlcyhhYnNQYXRoKX1gKTtcbiAgfVxuICBjb25zdCBwcmVmaXg6IHN0cmluZyA9IHByZWZpeE1hdGNoWzFdO1xuICBjb25zdCB0YWlsOiBzdHJpbmcgPSBhYnNQYXRoLnN1YnN0cmluZyhwcmVmaXhNYXRjaFswXS5sZW5ndGgpO1xuICBpZiAocHJlZml4ICE9PSBcIj9cIikge1xuICAgIC8vIFNob3J0IHNlcnZlciBwYXRoXG4gICAgY29uc3QgcmVzdWx0OiB1cmwuVVJMID0gbmV3IHVybC5VUkwoXCJmaWxlOi8vL1wiKTtcbiAgICByZXN1bHQuaG9zdCA9IHByZWZpeDtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBlbmNvZGVVUkkoYC8ke3RvRm9yd2FyZFNsYXNoZXModGFpbCl9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvLyBMb25nIHBhdGhcbiAgY29uc3QgdW5jTWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGwgPSBXSU5ET1dTX1VOQ19SRUdFWC5leGVjKHRhaWwpO1xuICBpZiAodW5jTWF0Y2ggPT09IG51bGwpIHtcbiAgICAvLyBMb25nIGRldmljZSBwYXRoXG4gICAgcmV0dXJuIGZvcm1hdEZpbGVVcmwoYC8ke3RvRm9yd2FyZFNsYXNoZXModGFpbCl9YCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTG9uZyBzZXJ2ZXIgcGF0aFxuICAgIGNvbnN0IGhvc3Q6IHN0cmluZyA9IHVuY01hdGNoWzFdO1xuICAgIGNvbnN0IHNlcnZlclBhdGg6IHN0cmluZyA9IHRhaWwuc3Vic3RyaW5nKHVuY01hdGNoWzBdLmxlbmd0aCk7XG4gICAgY29uc3QgcmVzdWx0OiB1cmwuVVJMID0gbmV3IHVybC5VUkwoXCJmaWxlOi8vL1wiKTtcbiAgICByZXN1bHQuaG9zdCA9IGhvc3Q7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gZW5jb2RlVVJJKGAvJHt0b0ZvcndhcmRTbGFzaGVzKHNlcnZlclBhdGgpfWApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSBQb3NpeCBwYXRoIHRvIGEgZnJvemVuIFVSTCBvYmplY3QuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBmcm9tUG9zaXhQYXRoKFwiL2Rpci9mb29cIik7XG4gKiAvLyAtPiBuZXcgVVJMKGZpbGU6Ly8vZGlyL2Zvb1wiKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYnNQYXRoIEFic29sdXRlIFBvc2l4IHBhdGggdG8gY29udmVydFxuICogQHJldHVybiBGcm96ZW4gYGZpbGU6Ly9gIFVSTCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUG9zaXhQYXRoKGFic1BhdGg6IHN0cmluZyk6IHVybC5VUkwge1xuICByZXR1cm4gZm9ybWF0RmlsZVVybChhYnNQYXRoKTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgdGhlIGJhY2t3YXJkIHNsYXNoZXMgYnkgZm9yd2FyZCBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRvRm9yd2FyZFNsYXNoZXMoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcXFwvZywgXCIvXCIpO1xufVxuXG4vKipcbiAqIFJlcGxhY2VzIGFsbCB0aGUgZm9yd2FyZCBzbGFzaGVzIGJ5IGJhY2t3YXJkIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmcuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdG9CYWNrd2FyZFNsYXNoZXMoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFxcIik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZyb3plbiBgZmlsZTovL2AgVVJMIHVzaW5nIHRoZSBzdXBwbGllZCBgcGF0aG5hbWVgLlxuICpcbiAqIEBwYXJhbSBwYXRobmFtZSBQYXRobmFtZSBmb3IgdGhlIFVSTCBvYmplY3QuXG4gKiBAcmV0dXJuIEZyb3plbiBgZmlsZTovL2AgVVJMIG9iamVjdC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBmb3JtYXRGaWxlVXJsKHBhdGhuYW1lOiBzdHJpbmcpOiB1cmwuVVJMIHtcbiAgY29uc3QgcmVzdWx0OiB1cmwuVVJMID0gbmV3IHVybC5VUkwoXCJmaWxlOi8vL1wiKTtcbiAgcmVzdWx0LnBhdGhuYW1lID0gZW5jb2RlVVJJKHBhdGhuYW1lKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=
