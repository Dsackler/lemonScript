"use strict";
/**
 * @module furi
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const is_windows_1 = __importDefault(require("is-windows"));
const url_1 = __importDefault(require("url"));
class InvalidFileUri extends TypeError {
    constructor(input) {
        super();
        this.input = input;
        this.message = `Invalid file URI: ${input}`;
        this.name = "TypeError [ERR_INVALID_FILE_URI]";
        this.code = "ERR_INVALID_FILE_URI";
    }
}
/**
 * A class representing a normalized absolute `file://` URI.
 *
 * This is a subclass of `url.URL` with the following extra checks:
 * - The protocol is `file:`.
 * - The pathname does not contain consecutive slashes (`a//b`) ("normalization").
 * - The pathname does not contain the `.` or `..` segments (enforced by `url.URL` already).
 * - The host `localhost` is represented as the empty string (enforced by `url.URL` already).
 *
 * This class extends `url.URL`. This means that you can pass it to any
 * function expecting a `url.URL`. It also means that the URI is always
 * absolute.
 *
 * Notes:
 * - A single trailing slash is allowed.
 * - The hostname is allowed to be any string. A non-empty string is used by Windows to represents
 *   files on a network drive. An empty string means `localhost`.
 * - The `username`, `password` and `port` properties are always `""` (enforced by `url.URL`
 *   already). This implies that `host` only contains `hostname`.
 * - The `search` and `hash` properties can have any value.
 */
class Furi extends url_1.default.URL {
    constructor(input) {
        const strInput = `${input}`;
        super(strInput);
        if (this.protocol !== "file:") {
            throw new InvalidFileUri(strInput);
        }
        if (this.pathname.indexOf("//") >= 0) {
            this.pathname = this.pathname.replace(/\/+/g, "/");
        }
    }
    get protocol() {
        return super.protocol;
    }
    set protocol(value) {
        if (value !== "file:") {
            return;
        }
        super.protocol = value;
    }
    get pathname() {
        return super.pathname;
    }
    set pathname(value) {
        if (value.indexOf("//") >= 0) {
            value = value.replace(/\/+/g, "/");
        }
        super.pathname = value;
    }
    hasTrailingSlash() {
        return this.pathname !== "/" && this.pathname.endsWith("/");
    }
    setTrailingSlash(hasTrailingSlash) {
        if (this.pathname === "/") {
            return;
        }
        if (this.pathname.endsWith("/")) {
            if (!hasTrailingSlash) {
                this.pathname = this.pathname.substring(0, this.pathname.length - 1);
            }
        }
        else if (hasTrailingSlash) {
            this.pathname = `${this.pathname}/`;
        }
    }
    toSysPath(windowsLongPath = false) {
        return toSysPath(this, windowsLongPath);
    }
    toPosixPath() {
        return toPosixPath(this);
    }
    toWindowsShortPath() {
        return toWindowsShortPath(this);
    }
    toWindowsLongPath() {
        return toWindowsLongPath(this);
    }
}
exports.Furi = Furi;
/**
 * Normalizes the input to a `Furi` instance.
 *
 * @param input URL string or instance to normalize.
 * @returns `Furi` instance. It is always a new instance.
 */
function asFuri(input) {
    if (input instanceof url_1.default.URL) {
        return new Furi(input.toString());
    }
    else {
        return new Furi(input);
    }
}
exports.asFuri = asFuri;
/**
 * Normalizes the input to a writable `URL` instance.
 *
 * @param input URL string or instance to normalize.
 */
function asWritableUrl(input) {
    return new url_1.default.URL(typeof input === "string" ? input : input.toString());
}
exports.asWritableUrl = asWritableUrl;
/**
 * Appends the provided components to the pathname of `base`.
 *
 * It does not mutate the inputs.
 * If component list is non-empty, the `hash` and `search` are set to the
 * empty string.
 *
 * @param base Base URL.
 * @param paths Paths to append. A path is either a string representing a relative or absolute file URI, or an array
 *              of components. When passing an array of components, each component will be URI-encoded before being
 *              appended.
 * @returns Joined URL.
 */
function join(base, ...paths) {
    const result = asFuri(base);
    if (paths.length === 0) {
        return result;
    }
    let hasTrailingSlash = result.hasTrailingSlash();
    const segments = result.pathname.split("/");
    for (const p of paths) {
        let pathStr;
        if (typeof p === "string") {
            if (p === "") {
                continue;
            }
            pathStr = p;
        }
        else {
            if (p.length === 0) {
                continue;
            }
            pathStr = `./${p.map(encodeURIComponent).join("/")}`;
        }
        for (const segment of pathStr.split("/")) {
            segments.push(segment);
            hasTrailingSlash = segment === "";
        }
    }
    result.pathname = segments.join("/");
    result.setTrailingSlash(hasTrailingSlash);
    result.hash = "";
    result.search = "";
    return result;
}
exports.join = join;
/**
 * Computes the relative or absolute `file://` URI from `from` to `to`.
 *
 * The result is an absolute URI only if the arguments have different hosts
 * (for example when computing a URI between different Windows networked drives).
 *
 * If both URIs are equivalent, returns `""`.
 *
 * Otherwise, returns a relative URI starting with `"./"` or `"../".
 *
 * @param from Source URI.
 * @param to Destination URI.
 * @returns Relative (or absolute) URI between the two arguments.
 */
function relative(from, to) {
    if (from === to) {
        return "";
    }
    const fromUri = asFuri(from);
    const toUri = asFuri(to);
    if (fromUri.host !== toUri.host) {
        return toUri.toString();
    }
    fromUri.setTrailingSlash(false);
    const fromSegments = fromUri.pathname === "/" ? [""] : fromUri.pathname.split("/");
    const toSegments = toUri.pathname === "/" ? [""] : toUri.pathname.split("/");
    let commonSegments = 0;
    for (let i = 0; i < Math.min(fromSegments.length, toSegments.length); i++) {
        const fromSegment = fromSegments[i];
        const toSegment = toSegments[i];
        if (fromSegment === toSegment) {
            commonSegments++;
        }
        else {
            break;
        }
    }
    const resultSegments = [];
    if (commonSegments === fromSegments.length) {
        if (commonSegments === toSegments.length) {
            // TODO: Handle hash and search
            return "";
        }
        resultSegments.push(".");
    }
    else {
        for (let i = commonSegments; i < fromSegments.length; i++) {
            resultSegments.push("..");
        }
    }
    resultSegments.push(...toSegments.slice(commonSegments));
    return resultSegments.join("/");
}
exports.relative = relative;
/**
 * Returns the basename of the file URI.
 *
 * This function is similar to Node's `require("path").basename`.
 *
 * @param furi Absolute `file://` URI.
 * @param ext Extension (will be removed if present).
 * @returns URI-encoded basename.
 */
function basename(furi, ext) {
    const readable = asFuri(furi);
    const components = readable.pathname
        .split("/")
        .filter(c => c !== "");
    const basename = components.length > 0 ? components[components.length - 1] : "";
    if (ext !== undefined && ext.length > 0 && ext.length < basename.length) {
        if (basename.endsWith(ext)) {
            return basename.substr(0, basename.length - ext.length);
        }
    }
    return basename;
}
exports.basename = basename;
/**
 * Returns the parent URL.
 *
 * If `input` is the root, it returns itself (saturation).
 * If `input` has a trailing separator, it is first removed.
 *
 * @param input Input URL.
 * @returns Parent URL.
 */
function parent(input) {
    const writable = asWritableUrl(input);
    const oldPathname = writable.pathname;
    const components = oldPathname.split("/");
    if (components[components.length - 1] === "") {
        // Remove trailing separator
        components.pop();
    }
    components.pop();
    writable.pathname = components.join("/");
    return writable;
}
exports.parent = parent;
/**
 * Converts a File URI to a system-dependent path.
 *
 * Use `toPosixPath`, `toWindowsShortPath` or `toWindowsLongPath` if you
 * want system-independent results.
 *
 * Example:
 * ```js
 * // On a Windows system:
 * toSysPath("file:///C:/dir/foo");
 * // -> "C:\\dir\\foo";
 * toSysPath("file:///C:/dir/foo", true);
 * // -> "\\\\?\\C:\\dir\\foo";
 *
 * // On a Posix system:
 * toSysPath("file:///dir/foo");
 * // -> "/dir/foo";
 * ```
 *
 * @param furi File URI to convert.
 * @param windowsLongPath Use long paths on Windows. (default: `false`)
 * @return System-dependent path.
 */
function toSysPath(furi, windowsLongPath = false) {
    if (is_windows_1.default()) {
        return windowsLongPath ? toWindowsLongPath(furi) : toWindowsShortPath(furi);
    }
    else {
        return toPosixPath(furi);
    }
}
exports.toSysPath = toSysPath;
/**
 * Converts a File URI to a Windows short path.
 *
 * The result is either a short device path or a short UNC server path.
 *
 * Example:
 * ```js
 * toSysPath("file:///C:/dir/foo");
 * // -> "C:\\dir\\foo";
 * toSysPath("file://server/Users/foo");
 * // -> "\\\\server\\Users\\foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Windows short path.
 */
function toWindowsShortPath(furi) {
    const urlObj = asFuri(furi);
    if (urlObj.host === "") {
        // Local drive path
        const pathname = urlObj.pathname.substring(1);
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        return toBackwardSlashes(forward);
    }
    else {
        // Server path
        const pathname = urlObj.pathname;
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\${urlObj.host}${backward}`;
    }
}
exports.toWindowsShortPath = toWindowsShortPath;
/**
 * Converts a File URI to a Windows long path.
 *
 * The result is either a long device path or a long UNC server path.
 *
 * Example:
 * ```js
 * toWindowsPath("file:///C:/dir/foo");
 * // -> "\\\\?\\C:\\dir\\foo";
 * toWindowsPath("file://server/Users/foo");
 * // -> "\\\\?\\unc\\server\\Users\\foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Windows long path.
 */
function toWindowsLongPath(furi) {
    const urlObj = asFuri(furi);
    if (urlObj.host === "") {
        // Local drive path
        const pathname = urlObj.pathname.substring(1);
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\?\\${backward}`;
    }
    else {
        // Server path
        const pathname = urlObj.pathname;
        const forward = pathname.split("/").map(decodeURIComponent).join("/");
        const backward = toBackwardSlashes(forward);
        return `\\\\?\\unc\\${urlObj.host}${backward}`;
    }
}
exports.toWindowsLongPath = toWindowsLongPath;
/**
 * Converts a File URI to a Posix path.
 *
 * Requires the host to be either an empty string or `"localhost"`.
 *
 * Example:
 * ```js
 * toPosixPath("file:///dir/foo");
 * // -> "/dir/foo";
 * ```
 *
 * @param furi File URI to convert.
 * @return Posix path.
 */
function toPosixPath(furi) {
    const urlObj = asFuri(furi);
    if (urlObj.host !== "" && urlObj.host !== "localhost") {
        assert_1.default.fail(`Expected \`host\` to be "" or "localhost": ${furi}`);
    }
    const pathname = urlObj.pathname;
    return pathname.split("/").map(decodeURIComponent).join("/");
}
exports.toPosixPath = toPosixPath;
/**
 * Converts an absolute system-dependent path to a frozen URL object.
 *
 * Use `fromPosixPath` or `fromWindowsPath` if you want system-independent
 * results.
 *
 * Example:
 * ```js
 * // On a Windows system:
 * fromSysPath("C:\\dir\\foo");
 * // -> new URL("file:///C:/dir/foo");
 *
 * // On a Posix system:
 * fromSysPath("/dir/foo");
 * // -> new URL("file:///dir/foo");
 * ```
 *
 * @param absPath Absolute system-dependent path to convert
 * @return Frozen `file://` URL object.
 */
function fromSysPath(absPath) {
    return is_windows_1.default() ? fromWindowsPath(absPath) : fromPosixPath(absPath);
}
exports.fromSysPath = fromSysPath;
const WINDOWS_PREFIX_REGEX = /^[\\/]{2,}([^\\/]+)(?:$|[\\/]+)/;
const WINDOWS_UNC_REGEX = /^unc(?:$|[\\/]+)([^\\/]+)(?:$|[\\/]+)/i;
/**
 * Converts an absolute Windows path to a frozen URL object.
 *
 * Example:
 * ```js
 * fromWindowsPath("C:\\dir\\foo");
 * // -> new URL(file:///C:/dir/foo");
 * fromWindowsPath("\\\\?\\unc\\server\\Users\\foo");
 * // -> new URL("file://server/Users/foo");
 * ```
 *
 * @param absPath Absolute Windows path to convert
 * @return Frozen `file://` URL object.
 */
function fromWindowsPath(absPath) {
    const prefixMatch = WINDOWS_PREFIX_REGEX.exec(absPath);
    if (prefixMatch === null) {
        // Short device path
        return formatFileUrl(`/${toForwardSlashes(absPath)}`);
    }
    const prefix = prefixMatch[1];
    const tail = absPath.substring(prefixMatch[0].length);
    if (prefix !== "?") {
        // Short server path
        const result = new url_1.default.URL("file:///");
        result.host = prefix;
        result.pathname = encodeURI(`/${toForwardSlashes(tail)}`);
        return result;
    }
    // Long path
    const uncMatch = WINDOWS_UNC_REGEX.exec(tail);
    if (uncMatch === null) {
        // Long device path
        return formatFileUrl(`/${toForwardSlashes(tail)}`);
    }
    else {
        // Long server path
        const host = uncMatch[1];
        const serverPath = tail.substring(uncMatch[0].length);
        const result = new url_1.default.URL("file:///");
        result.host = host;
        result.pathname = encodeURI(`/${toForwardSlashes(serverPath)}`);
        return result;
    }
}
exports.fromWindowsPath = fromWindowsPath;
/**
 * Converts an absolute Posix path to a frozen URL object.
 *
 * Example:
 * ```js
 * fromPosixPath("/dir/foo");
 * // -> new URL(file:///dir/foo");
 * ```
 *
 * @param absPath Absolute Posix path to convert
 * @return Frozen `file://` URL object.
 */
function fromPosixPath(absPath) {
    return formatFileUrl(absPath);
}
exports.fromPosixPath = fromPosixPath;
/**
 * Replaces all the backward slashes by forward slashes.
 *
 * @param str Input string.
 * @internal
 */
function toForwardSlashes(str) {
    return str.replace(/\\/g, "/");
}
/**
 * Replaces all the forward slashes by backward slashes.
 *
 * @param str Input string.
 * @internal
 */
function toBackwardSlashes(str) {
    return str.replace(/\//g, "\\");
}
/**
 * Creates a frozen `file://` URL using the supplied `pathname`.
 *
 * @param pathname Pathname for the URL object.
 * @return Frozen `file://` URL object.
 * @internal
 */
function formatFileUrl(pathname) {
    const result = new url_1.default.URL("file:///");
    result.pathname = encodeURI(pathname);
    return result;
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,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OUQsTUFBTSxNQUFNLEdBQVksSUFBSSxhQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQ25CLE1BQU0sQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2hFLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7QUFDSCxDQUFDO0FBN0JELDBDQTZCQztBQUVEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsU0FBZ0IsYUFBYSxDQUFDLE9BQWU7SUFDM0MsT0FBTyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDaEMsQ0FBQztBQUZELHNDQUVDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLGdCQUFnQixDQUFDLEdBQVc7SUFDbkMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFTLGlCQUFpQixDQUFDLEdBQVc7SUFDcEMsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNsQyxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBUyxhQUFhLENBQUMsUUFBZ0I7SUFDckMsTUFBTSxNQUFNLEdBQVksSUFBSSxhQUFHLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ2hELE1BQU0sQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3RDLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgZnVyaVxuICovXG5cbmltcG9ydCBhc3NlcnQgZnJvbSBcImFzc2VydFwiO1xuaW1wb3J0IGlzV2luZG93cyBmcm9tIFwiaXMtd2luZG93c1wiO1xuaW1wb3J0IHVybCBmcm9tIFwidXJsXCI7XG5cbmNsYXNzIEludmFsaWRGaWxlVXJpIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgcHVibGljIGlucHV0OiBzdHJpbmc7XG4gIHB1YmxpYyBjb2RlOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoaW5wdXQ6IHN0cmluZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIGZpbGUgVVJJOiAke2lucHV0fWA7XG4gICAgdGhpcy5uYW1lID0gXCJUeXBlRXJyb3IgW0VSUl9JTlZBTElEX0ZJTEVfVVJJXVwiO1xuICAgIHRoaXMuY29kZSA9IFwiRVJSX0lOVkFMSURfRklMRV9VUklcIjtcbiAgfVxufVxuXG4vKipcbiAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgbm9ybWFsaXplZCBhYnNvbHV0ZSBgZmlsZTovL2AgVVJJLlxuICpcbiAqIFRoaXMgaXMgYSBzdWJjbGFzcyBvZiBgdXJsLlVSTGAgd2l0aCB0aGUgZm9sbG93aW5nIGV4dHJhIGNoZWNrczpcbiAqIC0gVGhlIHByb3RvY29sIGlzIGBmaWxlOmAuXG4gKiAtIFRoZSBwYXRobmFtZSBkb2VzIG5vdCBjb250YWluIGNvbnNlY3V0aXZlIHNsYXNoZXMgKGBhLy9iYCkgKFwibm9ybWFsaXphdGlvblwiKS5cbiAqIC0gVGhlIHBhdGhuYW1lIGRvZXMgbm90IGNvbnRhaW4gdGhlIGAuYCBvciBgLi5gIHNlZ21lbnRzIChlbmZvcmNlZCBieSBgdXJsLlVSTGAgYWxyZWFkeSkuXG4gKiAtIFRoZSBob3N0IGBsb2NhbGhvc3RgIGlzIHJlcHJlc2VudGVkIGFzIHRoZSBlbXB0eSBzdHJpbmcgKGVuZm9yY2VkIGJ5IGB1cmwuVVJMYCBhbHJlYWR5KS5cbiAqXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMgYHVybC5VUkxgLiBUaGlzIG1lYW5zIHRoYXQgeW91IGNhbiBwYXNzIGl0IHRvIGFueVxuICogZnVuY3Rpb24gZXhwZWN0aW5nIGEgYHVybC5VUkxgLiBJdCBhbHNvIG1lYW5zIHRoYXQgdGhlIFVSSSBpcyBhbHdheXNcbiAqIGFic29sdXRlLlxuICpcbiAqIE5vdGVzOlxuICogLSBBIHNpbmdsZSB0cmFpbGluZyBzbGFzaCBpcyBhbGxvd2VkLlxuICogLSBUaGUgaG9zdG5hbWUgaXMgYWxsb3dlZCB0byBiZSBhbnkgc3RyaW5nLiBBIG5vbi1lbXB0eSBzdHJpbmcgaXMgdXNlZCBieSBXaW5kb3dzIHRvIHJlcHJlc2VudHNcbiAqICAgZmlsZXMgb24gYSBuZXR3b3JrIGRyaXZlLiBBbiBlbXB0eSBzdHJpbmcgbWVhbnMgYGxvY2FsaG9zdGAuXG4gKiAtIFRoZSBgdXNlcm5hbWVgLCBgcGFzc3dvcmRgIGFuZCBgcG9ydGAgcHJvcGVydGllcyBhcmUgYWx3YXlzIGBcIlwiYCAoZW5mb3JjZWQgYnkgYHVybC5VUkxgXG4gKiAgIGFscmVhZHkpLiBUaGlzIGltcGxpZXMgdGhhdCBgaG9zdGAgb25seSBjb250YWlucyBgaG9zdG5hbWVgLlxuICogLSBUaGUgYHNlYXJjaGAgYW5kIGBoYXNoYCBwcm9wZXJ0aWVzIGNhbiBoYXZlIGFueSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEZ1cmkgZXh0ZW5kcyB1cmwuVVJMIHtcbiAgY29uc3RydWN0b3IoaW5wdXQ6IFVybExpa2UpIHtcbiAgICBjb25zdCBzdHJJbnB1dDogc3RyaW5nID0gYCR7aW5wdXR9YDtcbiAgICBzdXBlcihzdHJJbnB1dCk7XG4gICAgaWYgKHRoaXMucHJvdG9jb2wgIT09IFwiZmlsZTpcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRGaWxlVXJpKHN0cklucHV0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGF0aG5hbWUuaW5kZXhPZihcIi8vXCIpID49IDApIHtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBwcm90b2NvbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdXBlci5wcm90b2NvbDtcbiAgfVxuXG4gIHNldCBwcm90b2NvbCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHZhbHVlICE9PSBcImZpbGU6XCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucHJvdG9jb2wgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBwYXRobmFtZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBzdXBlci5wYXRobmFtZTtcbiAgfVxuXG4gIHNldCBwYXRobmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgaWYgKHZhbHVlLmluZGV4T2YoXCIvL1wiKSA+PSAwKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcLysvZywgXCIvXCIpO1xuICAgIH1cbiAgICBzdXBlci5wYXRobmFtZSA9IHZhbHVlO1xuICB9XG5cbiAgaGFzVHJhaWxpbmdTbGFzaCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5wYXRobmFtZSAhPT0gXCIvXCIgJiYgdGhpcy5wYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIH1cblxuICBzZXRUcmFpbGluZ1NsYXNoKGhhc1RyYWlsaW5nU2xhc2g6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYXRobmFtZSA9PT0gXCIvXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICBpZiAoIWhhc1RyYWlsaW5nU2xhc2gpIHtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHRoaXMucGF0aG5hbWUuc3Vic3RyaW5nKDAsIHRoaXMucGF0aG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNUcmFpbGluZ1NsYXNoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gYCR7dGhpcy5wYXRobmFtZX0vYDtcbiAgICB9XG4gIH1cblxuICB0b1N5c1BhdGgod2luZG93c0xvbmdQYXRoOiBib29sZWFuID0gZmFsc2UpOiBzdHJpbmcge1xuICAgIHJldHVybiB0b1N5c1BhdGgodGhpcywgd2luZG93c0xvbmdQYXRoKTtcbiAgfVxuXG4gIHRvUG9zaXhQYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvUG9zaXhQYXRoKHRoaXMpO1xuICB9XG5cbiAgdG9XaW5kb3dzU2hvcnRQYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvV2luZG93c1Nob3J0UGF0aCh0aGlzKTtcbiAgfVxuXG4gIHRvV2luZG93c0xvbmdQYXRoKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRvV2luZG93c0xvbmdQYXRoKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogQSBgVVJMYCBpbnN0YW5jZSBvciB2YWxpZCBfYWJzb2x1dGVfIFVSTCBzdHJpbmcuXG4gKi9cbmV4cG9ydCB0eXBlIFVybExpa2UgPSB1cmwuVVJMIHwgc3RyaW5nO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGlucHV0IHRvIGEgYEZ1cmlgIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBpbnB1dCBVUkwgc3RyaW5nIG9yIGluc3RhbmNlIHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIGBGdXJpYCBpbnN0YW5jZS4gSXQgaXMgYWx3YXlzIGEgbmV3IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNGdXJpKGlucHV0OiBVcmxMaWtlKTogRnVyaSB7XG4gIGlmIChpbnB1dCBpbnN0YW5jZW9mIHVybC5VUkwpIHtcbiAgICByZXR1cm4gbmV3IEZ1cmkoaW5wdXQudG9TdHJpbmcoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBGdXJpKGlucHV0KTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGlucHV0IHRvIGEgd3JpdGFibGUgYFVSTGAgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGlucHV0IFVSTCBzdHJpbmcgb3IgaW5zdGFuY2UgdG8gbm9ybWFsaXplLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNXcml0YWJsZVVybChpbnB1dDogVXJsTGlrZSk6IHVybC5VUkwge1xuICByZXR1cm4gbmV3IHVybC5VUkwodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gaW5wdXQgOiBpbnB1dC50b1N0cmluZygpKTtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBwcm92aWRlZCBjb21wb25lbnRzIHRvIHRoZSBwYXRobmFtZSBvZiBgYmFzZWAuXG4gKlxuICogSXQgZG9lcyBub3QgbXV0YXRlIHRoZSBpbnB1dHMuXG4gKiBJZiBjb21wb25lbnQgbGlzdCBpcyBub24tZW1wdHksIHRoZSBgaGFzaGAgYW5kIGBzZWFyY2hgIGFyZSBzZXQgdG8gdGhlXG4gKiBlbXB0eSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJhc2UgQmFzZSBVUkwuXG4gKiBAcGFyYW0gcGF0aHMgUGF0aHMgdG8gYXBwZW5kLiBBIHBhdGggaXMgZWl0aGVyIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIHJlbGF0aXZlIG9yIGFic29sdXRlIGZpbGUgVVJJLCBvciBhbiBhcnJheVxuICogICAgICAgICAgICAgIG9mIGNvbXBvbmVudHMuIFdoZW4gcGFzc2luZyBhbiBhcnJheSBvZiBjb21wb25lbnRzLCBlYWNoIGNvbXBvbmVudCB3aWxsIGJlIFVSSS1lbmNvZGVkIGJlZm9yZSBiZWluZ1xuICogICAgICAgICAgICAgIGFwcGVuZGVkLlxuICogQHJldHVybnMgSm9pbmVkIFVSTC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGpvaW4oYmFzZTogVXJsTGlrZSwgLi4ucGF0aHM6IHJlYWRvbmx5IChzdHJpbmcgfCByZWFkb25seSBzdHJpbmdbXSlbXSk6IEZ1cmkge1xuICBjb25zdCByZXN1bHQ6IEZ1cmkgPSBhc0Z1cmkoYmFzZSk7XG4gIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgbGV0IGhhc1RyYWlsaW5nU2xhc2g6IGJvb2xlYW4gPSByZXN1bHQuaGFzVHJhaWxpbmdTbGFzaCgpO1xuICBjb25zdCBzZWdtZW50czogc3RyaW5nW10gPSByZXN1bHQucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICBmb3IgKGNvbnN0IHAgb2YgcGF0aHMpIHtcbiAgICBsZXQgcGF0aFN0cjogc3RyaW5nO1xuICAgIGlmICh0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHAgPT09IFwiXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBwYXRoU3RyID0gcDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcGF0aFN0ciA9IGAuLyR7cC5tYXAoZW5jb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiL1wiKX1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aFN0ci5zcGxpdChcIi9cIikpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICBoYXNUcmFpbGluZ1NsYXNoID0gc2VnbWVudCA9PT0gXCJcIjtcbiAgICB9XG4gIH1cbiAgcmVzdWx0LnBhdGhuYW1lID0gc2VnbWVudHMuam9pbihcIi9cIik7XG4gIHJlc3VsdC5zZXRUcmFpbGluZ1NsYXNoKGhhc1RyYWlsaW5nU2xhc2gpO1xuICByZXN1bHQuaGFzaCA9IFwiXCI7XG4gIHJlc3VsdC5zZWFyY2ggPSBcIlwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSByZWxhdGl2ZSBvciBhYnNvbHV0ZSBgZmlsZTovL2AgVVJJIGZyb20gYGZyb21gIHRvIGB0b2AuXG4gKlxuICogVGhlIHJlc3VsdCBpcyBhbiBhYnNvbHV0ZSBVUkkgb25seSBpZiB0aGUgYXJndW1lbnRzIGhhdmUgZGlmZmVyZW50IGhvc3RzXG4gKiAoZm9yIGV4YW1wbGUgd2hlbiBjb21wdXRpbmcgYSBVUkkgYmV0d2VlbiBkaWZmZXJlbnQgV2luZG93cyBuZXR3b3JrZWQgZHJpdmVzKS5cbiAqXG4gKiBJZiBib3RoIFVSSXMgYXJlIGVxdWl2YWxlbnQsIHJldHVybnMgYFwiXCJgLlxuICpcbiAqIE90aGVyd2lzZSwgcmV0dXJucyBhIHJlbGF0aXZlIFVSSSBzdGFydGluZyB3aXRoIGBcIi4vXCJgIG9yIGBcIi4uL1wiLlxuICpcbiAqIEBwYXJhbSBmcm9tIFNvdXJjZSBVUkkuXG4gKiBAcGFyYW0gdG8gRGVzdGluYXRpb24gVVJJLlxuICogQHJldHVybnMgUmVsYXRpdmUgKG9yIGFic29sdXRlKSBVUkkgYmV0d2VlbiB0aGUgdHdvIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbGF0aXZlKGZyb206IFVybExpa2UsIHRvOiBVcmxMaWtlKTogc3RyaW5nIHtcbiAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgY29uc3QgZnJvbVVyaTogRnVyaSA9IGFzRnVyaShmcm9tKTtcbiAgY29uc3QgdG9Vcmk6IEZ1cmkgPSBhc0Z1cmkodG8pO1xuICBpZiAoZnJvbVVyaS5ob3N0ICE9PSB0b1VyaS5ob3N0KSB7XG4gICAgcmV0dXJuIHRvVXJpLnRvU3RyaW5nKCk7XG4gIH1cbiAgZnJvbVVyaS5zZXRUcmFpbGluZ1NsYXNoKGZhbHNlKTtcbiAgY29uc3QgZnJvbVNlZ21lbnRzOiBzdHJpbmdbXSA9IGZyb21VcmkucGF0aG5hbWUgPT09IFwiL1wiID8gW1wiXCJdIDogZnJvbVVyaS5wYXRobmFtZS5zcGxpdChcIi9cIik7XG4gIGNvbnN0IHRvU2VnbWVudHM6IHN0cmluZ1tdID0gdG9VcmkucGF0aG5hbWUgPT09IFwiL1wiID8gW1wiXCJdIDogdG9VcmkucGF0aG5hbWUuc3BsaXQoXCIvXCIpO1xuICBsZXQgY29tbW9uU2VnbWVudHM6IG51bWJlciA9IDA7XG4gIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCBNYXRoLm1pbihmcm9tU2VnbWVudHMubGVuZ3RoLCB0b1NlZ21lbnRzLmxlbmd0aCk7IGkrKykge1xuICAgIGNvbnN0IGZyb21TZWdtZW50OiBzdHJpbmcgPSBmcm9tU2VnbWVudHNbaV07XG4gICAgY29uc3QgdG9TZWdtZW50OiBzdHJpbmcgPSB0b1NlZ21lbnRzW2ldO1xuICAgIGlmIChmcm9tU2VnbWVudCA9PT0gdG9TZWdtZW50KSB7XG4gICAgICBjb21tb25TZWdtZW50cysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgcmVzdWx0U2VnbWVudHM6IHN0cmluZ1tdID0gW107XG4gIGlmIChjb21tb25TZWdtZW50cyA9PT0gZnJvbVNlZ21lbnRzLmxlbmd0aCkge1xuICAgIGlmIChjb21tb25TZWdtZW50cyA9PT0gdG9TZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIFRPRE86IEhhbmRsZSBoYXNoIGFuZCBzZWFyY2hcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXN1bHRTZWdtZW50cy5wdXNoKFwiLlwiKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpOiBudW1iZXIgPSBjb21tb25TZWdtZW50czsgaSA8IGZyb21TZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0U2VnbWVudHMucHVzaChcIi4uXCIpO1xuICAgIH1cbiAgfVxuICByZXN1bHRTZWdtZW50cy5wdXNoKC4uLnRvU2VnbWVudHMuc2xpY2UoY29tbW9uU2VnbWVudHMpKTtcbiAgcmV0dXJuIHJlc3VsdFNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGJhc2VuYW1lIG9mIHRoZSBmaWxlIFVSSS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHNpbWlsYXIgdG8gTm9kZSdzIGByZXF1aXJlKFwicGF0aFwiKS5iYXNlbmFtZWAuXG4gKlxuICogQHBhcmFtIGZ1cmkgQWJzb2x1dGUgYGZpbGU6Ly9gIFVSSS5cbiAqIEBwYXJhbSBleHQgRXh0ZW5zaW9uICh3aWxsIGJlIHJlbW92ZWQgaWYgcHJlc2VudCkuXG4gKiBAcmV0dXJucyBVUkktZW5jb2RlZCBiYXNlbmFtZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2VuYW1lKGZ1cmk6IFVybExpa2UsIGV4dD86IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHJlYWRhYmxlOiB1cmwuVVJMID0gYXNGdXJpKGZ1cmkpO1xuICBjb25zdCBjb21wb25lbnRzOiByZWFkb25seSBzdHJpbmdbXSA9IHJlYWRhYmxlLnBhdGhuYW1lXG4gICAgLnNwbGl0KFwiL1wiKVxuICAgIC5maWx0ZXIoYyA9PiBjICE9PSBcIlwiKTtcbiAgY29uc3QgYmFzZW5hbWU6IHN0cmluZyA9IGNvbXBvbmVudHMubGVuZ3RoID4gMCA/IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA6IFwiXCI7XG4gIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDwgYmFzZW5hbWUubGVuZ3RoKSB7XG4gICAgaWYgKGJhc2VuYW1lLmVuZHNXaXRoKGV4dCkpIHtcbiAgICAgIHJldHVybiBiYXNlbmFtZS5zdWJzdHIoMCwgYmFzZW5hbWUubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlbmFtZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnQgVVJMLlxuICpcbiAqIElmIGBpbnB1dGAgaXMgdGhlIHJvb3QsIGl0IHJldHVybnMgaXRzZWxmIChzYXR1cmF0aW9uKS5cbiAqIElmIGBpbnB1dGAgaGFzIGEgdHJhaWxpbmcgc2VwYXJhdG9yLCBpdCBpcyBmaXJzdCByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSBpbnB1dCBJbnB1dCBVUkwuXG4gKiBAcmV0dXJucyBQYXJlbnQgVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50KGlucHV0OiBVcmxMaWtlKTogdXJsLlVSTCB7XG4gIGNvbnN0IHdyaXRhYmxlOiB1cmwuVVJMID0gYXNXcml0YWJsZVVybChpbnB1dCk7XG4gIGNvbnN0IG9sZFBhdGhuYW1lOiBzdHJpbmcgPSB3cml0YWJsZS5wYXRobmFtZTtcbiAgY29uc3QgY29tcG9uZW50czogc3RyaW5nW10gPSBvbGRQYXRobmFtZS5zcGxpdChcIi9cIik7XG4gIGlmIChjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0gPT09IFwiXCIpIHtcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgc2VwYXJhdG9yXG4gICAgY29tcG9uZW50cy5wb3AoKTtcbiAgfVxuICBjb21wb25lbnRzLnBvcCgpO1xuICB3cml0YWJsZS5wYXRobmFtZSA9IGNvbXBvbmVudHMuam9pbihcIi9cIik7XG4gIHJldHVybiB3cml0YWJsZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEZpbGUgVVJJIHRvIGEgc3lzdGVtLWRlcGVuZGVudCBwYXRoLlxuICpcbiAqIFVzZSBgdG9Qb3NpeFBhdGhgLCBgdG9XaW5kb3dzU2hvcnRQYXRoYCBvciBgdG9XaW5kb3dzTG9uZ1BhdGhgIGlmIHlvdVxuICogd2FudCBzeXN0ZW0taW5kZXBlbmRlbnQgcmVzdWx0cy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIC8vIE9uIGEgV2luZG93cyBzeXN0ZW06XG4gKiB0b1N5c1BhdGgoXCJmaWxlOi8vL0M6L2Rpci9mb29cIik7XG4gKiAvLyAtPiBcIkM6XFxcXGRpclxcXFxmb29cIjtcbiAqIHRvU3lzUGF0aChcImZpbGU6Ly8vQzovZGlyL2Zvb1wiLCB0cnVlKTtcbiAqIC8vIC0+IFwiXFxcXFxcXFw/XFxcXEM6XFxcXGRpclxcXFxmb29cIjtcbiAqXG4gKiAvLyBPbiBhIFBvc2l4IHN5c3RlbTpcbiAqIHRvU3lzUGF0aChcImZpbGU6Ly8vZGlyL2Zvb1wiKTtcbiAqIC8vIC0+IFwiL2Rpci9mb29cIjtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBmdXJpIEZpbGUgVVJJIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gd2luZG93c0xvbmdQYXRoIFVzZSBsb25nIHBhdGhzIG9uIFdpbmRvd3MuIChkZWZhdWx0OiBgZmFsc2VgKVxuICogQHJldHVybiBTeXN0ZW0tZGVwZW5kZW50IHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N5c1BhdGgoZnVyaTogVXJsTGlrZSwgd2luZG93c0xvbmdQYXRoOiBib29sZWFuID0gZmFsc2UpOiBzdHJpbmcge1xuICBpZiAoaXNXaW5kb3dzKCkpIHtcbiAgICByZXR1cm4gd2luZG93c0xvbmdQYXRoID8gdG9XaW5kb3dzTG9uZ1BhdGgoZnVyaSkgOiB0b1dpbmRvd3NTaG9ydFBhdGgoZnVyaSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvUG9zaXhQYXRoKGZ1cmkpO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBGaWxlIFVSSSB0byBhIFdpbmRvd3Mgc2hvcnQgcGF0aC5cbiAqXG4gKiBUaGUgcmVzdWx0IGlzIGVpdGhlciBhIHNob3J0IGRldmljZSBwYXRoIG9yIGEgc2hvcnQgVU5DIHNlcnZlciBwYXRoLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogdG9TeXNQYXRoKFwiZmlsZTovLy9DOi9kaXIvZm9vXCIpO1xuICogLy8gLT4gXCJDOlxcXFxkaXJcXFxcZm9vXCI7XG4gKiB0b1N5c1BhdGgoXCJmaWxlOi8vc2VydmVyL1VzZXJzL2Zvb1wiKTtcbiAqIC8vIC0+IFwiXFxcXFxcXFxzZXJ2ZXJcXFxcVXNlcnNcXFxcZm9vXCI7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZnVyaSBGaWxlIFVSSSB0byBjb252ZXJ0LlxuICogQHJldHVybiBXaW5kb3dzIHNob3J0IHBhdGguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1dpbmRvd3NTaG9ydFBhdGgoZnVyaTogVXJsTGlrZSk6IHN0cmluZyB7XG4gIGNvbnN0IHVybE9iajogdXJsLlVSTCA9IGFzRnVyaShmdXJpKTtcbiAgaWYgKHVybE9iai5ob3N0ID09PSBcIlwiKSB7XG4gICAgLy8gTG9jYWwgZHJpdmUgcGF0aFxuICAgIGNvbnN0IHBhdGhuYW1lOiBzdHJpbmcgPSB1cmxPYmoucGF0aG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIGNvbnN0IGZvcndhcmQ6IHN0cmluZyA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiL1wiKTtcbiAgICByZXR1cm4gdG9CYWNrd2FyZFNsYXNoZXMoZm9yd2FyZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2VydmVyIHBhdGhcbiAgICBjb25zdCBwYXRobmFtZTogc3RyaW5nID0gdXJsT2JqLnBhdGhuYW1lO1xuICAgIGNvbnN0IGZvcndhcmQ6IHN0cmluZyA9IHBhdGhuYW1lLnNwbGl0KFwiL1wiKS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KS5qb2luKFwiL1wiKTtcbiAgICBjb25zdCBiYWNrd2FyZDogc3RyaW5nID0gdG9CYWNrd2FyZFNsYXNoZXMoZm9yd2FyZCk7XG4gICAgcmV0dXJuIGBcXFxcXFxcXCR7dXJsT2JqLmhvc3R9JHtiYWNrd2FyZH1gO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBGaWxlIFVSSSB0byBhIFdpbmRvd3MgbG9uZyBwYXRoLlxuICpcbiAqIFRoZSByZXN1bHQgaXMgZWl0aGVyIGEgbG9uZyBkZXZpY2UgcGF0aCBvciBhIGxvbmcgVU5DIHNlcnZlciBwYXRoLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogdG9XaW5kb3dzUGF0aChcImZpbGU6Ly8vQzovZGlyL2Zvb1wiKTtcbiAqIC8vIC0+IFwiXFxcXFxcXFw/XFxcXEM6XFxcXGRpclxcXFxmb29cIjtcbiAqIHRvV2luZG93c1BhdGgoXCJmaWxlOi8vc2VydmVyL1VzZXJzL2Zvb1wiKTtcbiAqIC8vIC0+IFwiXFxcXFxcXFw/XFxcXHVuY1xcXFxzZXJ2ZXJcXFxcVXNlcnNcXFxcZm9vXCI7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZnVyaSBGaWxlIFVSSSB0byBjb252ZXJ0LlxuICogQHJldHVybiBXaW5kb3dzIGxvbmcgcGF0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvV2luZG93c0xvbmdQYXRoKGZ1cmk6IFVybExpa2UpOiBzdHJpbmcge1xuICBjb25zdCB1cmxPYmo6IEZ1cmkgPSBhc0Z1cmkoZnVyaSk7XG4gIGlmICh1cmxPYmouaG9zdCA9PT0gXCJcIikge1xuICAgIC8vIExvY2FsIGRyaXZlIHBhdGhcbiAgICBjb25zdCBwYXRobmFtZTogc3RyaW5nID0gdXJsT2JqLnBhdGhuYW1lLnN1YnN0cmluZygxKTtcbiAgICBjb25zdCBmb3J3YXJkOiBzdHJpbmcgPSBwYXRobmFtZS5zcGxpdChcIi9cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7XG4gICAgY29uc3QgYmFja3dhcmQ6IHN0cmluZyA9IHRvQmFja3dhcmRTbGFzaGVzKGZvcndhcmQpO1xuICAgIHJldHVybiBgXFxcXFxcXFw/XFxcXCR7YmFja3dhcmR9YDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTZXJ2ZXIgcGF0aFxuICAgIGNvbnN0IHBhdGhuYW1lOiBzdHJpbmcgPSB1cmxPYmoucGF0aG5hbWU7XG4gICAgY29uc3QgZm9yd2FyZDogc3RyaW5nID0gcGF0aG5hbWUuc3BsaXQoXCIvXCIpLm1hcChkZWNvZGVVUklDb21wb25lbnQpLmpvaW4oXCIvXCIpO1xuICAgIGNvbnN0IGJhY2t3YXJkOiBzdHJpbmcgPSB0b0JhY2t3YXJkU2xhc2hlcyhmb3J3YXJkKTtcbiAgICByZXR1cm4gYFxcXFxcXFxcP1xcXFx1bmNcXFxcJHt1cmxPYmouaG9zdH0ke2JhY2t3YXJkfWA7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIEZpbGUgVVJJIHRvIGEgUG9zaXggcGF0aC5cbiAqXG4gKiBSZXF1aXJlcyB0aGUgaG9zdCB0byBiZSBlaXRoZXIgYW4gZW1wdHkgc3RyaW5nIG9yIGBcImxvY2FsaG9zdFwiYC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIHRvUG9zaXhQYXRoKFwiZmlsZTovLy9kaXIvZm9vXCIpO1xuICogLy8gLT4gXCIvZGlyL2Zvb1wiO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGZ1cmkgRmlsZSBVUkkgdG8gY29udmVydC5cbiAqIEByZXR1cm4gUG9zaXggcGF0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUG9zaXhQYXRoKGZ1cmk6IFVybExpa2UpOiBzdHJpbmcge1xuICBjb25zdCB1cmxPYmo6IEZ1cmkgPSBhc0Z1cmkoZnVyaSk7XG4gIGlmICh1cmxPYmouaG9zdCAhPT0gXCJcIiAmJiB1cmxPYmouaG9zdCAhPT0gXCJsb2NhbGhvc3RcIikge1xuICAgIGFzc2VydC5mYWlsKGBFeHBlY3RlZCBcXGBob3N0XFxgIHRvIGJlIFwiXCIgb3IgXCJsb2NhbGhvc3RcIjogJHtmdXJpfWApO1xuICB9XG4gIGNvbnN0IHBhdGhuYW1lOiBzdHJpbmcgPSB1cmxPYmoucGF0aG5hbWU7XG4gIHJldHVybiBwYXRobmFtZS5zcGxpdChcIi9cIikubWFwKGRlY29kZVVSSUNvbXBvbmVudCkuam9pbihcIi9cIik7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYWJzb2x1dGUgc3lzdGVtLWRlcGVuZGVudCBwYXRoIHRvIGEgZnJvemVuIFVSTCBvYmplY3QuXG4gKlxuICogVXNlIGBmcm9tUG9zaXhQYXRoYCBvciBgZnJvbVdpbmRvd3NQYXRoYCBpZiB5b3Ugd2FudCBzeXN0ZW0taW5kZXBlbmRlbnRcbiAqIHJlc3VsdHMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiAvLyBPbiBhIFdpbmRvd3Mgc3lzdGVtOlxuICogZnJvbVN5c1BhdGgoXCJDOlxcXFxkaXJcXFxcZm9vXCIpO1xuICogLy8gLT4gbmV3IFVSTChcImZpbGU6Ly8vQzovZGlyL2Zvb1wiKTtcbiAqXG4gKiAvLyBPbiBhIFBvc2l4IHN5c3RlbTpcbiAqIGZyb21TeXNQYXRoKFwiL2Rpci9mb29cIik7XG4gKiAvLyAtPiBuZXcgVVJMKFwiZmlsZTovLy9kaXIvZm9vXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFic1BhdGggQWJzb2x1dGUgc3lzdGVtLWRlcGVuZGVudCBwYXRoIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4gRnJvemVuIGBmaWxlOi8vYCBVUkwgb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN5c1BhdGgoYWJzUGF0aDogc3RyaW5nKTogdXJsLlVSTCB7XG4gIHJldHVybiBpc1dpbmRvd3MoKSA/IGZyb21XaW5kb3dzUGF0aChhYnNQYXRoKSA6IGZyb21Qb3NpeFBhdGgoYWJzUGF0aCk7XG59XG5cbmNvbnN0IFdJTkRPV1NfUFJFRklYX1JFR0VYOiBSZWdFeHAgPSAvXltcXFxcL117Mix9KFteXFxcXC9dKykoPzokfFtcXFxcL10rKS87XG5jb25zdCBXSU5ET1dTX1VOQ19SRUdFWDogUmVnRXhwID0gL151bmMoPzokfFtcXFxcL10rKShbXlxcXFwvXSspKD86JHxbXFxcXC9dKykvaTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhYnNvbHV0ZSBXaW5kb3dzIHBhdGggdG8gYSBmcm96ZW4gVVJMIG9iamVjdC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIGZyb21XaW5kb3dzUGF0aChcIkM6XFxcXGRpclxcXFxmb29cIik7XG4gKiAvLyAtPiBuZXcgVVJMKGZpbGU6Ly8vQzovZGlyL2Zvb1wiKTtcbiAqIGZyb21XaW5kb3dzUGF0aChcIlxcXFxcXFxcP1xcXFx1bmNcXFxcc2VydmVyXFxcXFVzZXJzXFxcXGZvb1wiKTtcbiAqIC8vIC0+IG5ldyBVUkwoXCJmaWxlOi8vc2VydmVyL1VzZXJzL2Zvb1wiKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYnNQYXRoIEFic29sdXRlIFdpbmRvd3MgcGF0aCB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIEZyb3plbiBgZmlsZTovL2AgVVJMIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21XaW5kb3dzUGF0aChhYnNQYXRoOiBzdHJpbmcpOiB1cmwuVVJMIHtcbiAgY29uc3QgcHJlZml4TWF0Y2g6IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGwgPSBXSU5ET1dTX1BSRUZJWF9SRUdFWC5leGVjKGFic1BhdGgpO1xuICBpZiAocHJlZml4TWF0Y2ggPT09IG51bGwpIHtcbiAgICAvLyBTaG9ydCBkZXZpY2UgcGF0aFxuICAgIHJldHVybiBmb3JtYXRGaWxlVXJsKGAvJHt0b0ZvcndhcmRTbGFzaGVzKGFic1BhdGgpfWApO1xuICB9XG4gIGNvbnN0IHByZWZpeDogc3RyaW5nID0gcHJlZml4TWF0Y2hbMV07XG4gIGNvbnN0IHRhaWw6IHN0cmluZyA9IGFic1BhdGguc3Vic3RyaW5nKHByZWZpeE1hdGNoWzBdLmxlbmd0aCk7XG4gIGlmIChwcmVmaXggIT09IFwiP1wiKSB7XG4gICAgLy8gU2hvcnQgc2VydmVyIHBhdGhcbiAgICBjb25zdCByZXN1bHQ6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChcImZpbGU6Ly8vXCIpO1xuICAgIHJlc3VsdC5ob3N0ID0gcHJlZml4O1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IGVuY29kZVVSSShgLyR7dG9Gb3J3YXJkU2xhc2hlcyh0YWlsKX1gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIC8vIExvbmcgcGF0aFxuICBjb25zdCB1bmNNYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCA9IFdJTkRPV1NfVU5DX1JFR0VYLmV4ZWModGFpbCk7XG4gIGlmICh1bmNNYXRjaCA9PT0gbnVsbCkge1xuICAgIC8vIExvbmcgZGV2aWNlIHBhdGhcbiAgICByZXR1cm4gZm9ybWF0RmlsZVVybChgLyR7dG9Gb3J3YXJkU2xhc2hlcyh0YWlsKX1gKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMb25nIHNlcnZlciBwYXRoXG4gICAgY29uc3QgaG9zdDogc3RyaW5nID0gdW5jTWF0Y2hbMV07XG4gICAgY29uc3Qgc2VydmVyUGF0aDogc3RyaW5nID0gdGFpbC5zdWJzdHJpbmcodW5jTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICBjb25zdCByZXN1bHQ6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChcImZpbGU6Ly8vXCIpO1xuICAgIHJlc3VsdC5ob3N0ID0gaG9zdDtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBlbmNvZGVVUkkoYC8ke3RvRm9yd2FyZFNsYXNoZXMoc2VydmVyUGF0aCl9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFic29sdXRlIFBvc2l4IHBhdGggdG8gYSBmcm96ZW4gVVJMIG9iamVjdC5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBganNcbiAqIGZyb21Qb3NpeFBhdGgoXCIvZGlyL2Zvb1wiKTtcbiAqIC8vIC0+IG5ldyBVUkwoZmlsZTovLy9kaXIvZm9vXCIpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFic1BhdGggQWJzb2x1dGUgUG9zaXggcGF0aCB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIEZyb3plbiBgZmlsZTovL2AgVVJMIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Qb3NpeFBhdGgoYWJzUGF0aDogc3RyaW5nKTogdXJsLlVSTCB7XG4gIHJldHVybiBmb3JtYXRGaWxlVXJsKGFic1BhdGgpO1xufVxuXG4vKipcbiAqIFJlcGxhY2VzIGFsbCB0aGUgYmFja3dhcmQgc2xhc2hlcyBieSBmb3J3YXJkIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmcuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdG9Gb3J3YXJkU2xhc2hlcyhzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG59XG5cbi8qKlxuICogUmVwbGFjZXMgYWxsIHRoZSBmb3J3YXJkIHNsYXNoZXMgYnkgYmFja3dhcmQgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gc3RyIElucHV0IHN0cmluZy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0b0JhY2t3YXJkU2xhc2hlcyhzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFwvL2csIFwiXFxcXFwiKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnJvemVuIGBmaWxlOi8vYCBVUkwgdXNpbmcgdGhlIHN1cHBsaWVkIGBwYXRobmFtZWAuXG4gKlxuICogQHBhcmFtIHBhdGhuYW1lIFBhdGhuYW1lIGZvciB0aGUgVVJMIG9iamVjdC5cbiAqIEByZXR1cm4gRnJvemVuIGBmaWxlOi8vYCBVUkwgb2JqZWN0LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEZpbGVVcmwocGF0aG5hbWU6IHN0cmluZyk6IHVybC5VUkwge1xuICBjb25zdCByZXN1bHQ6IHVybC5VUkwgPSBuZXcgdXJsLlVSTChcImZpbGU6Ly8vXCIpO1xuICByZXN1bHQucGF0aG5hbWUgPSBlbmNvZGVVUkkocGF0aG5hbWUpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==
